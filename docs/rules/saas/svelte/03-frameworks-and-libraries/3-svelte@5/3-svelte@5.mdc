---
description: Svelte 5 best practices covering runes, reactivity, web components, TypeScript integration, and performance optimization for building reactive UI components
globs:
  - "donaction-saas/**/*.svelte"
  - "donaction-saas/**/*.svelte.ts"
  - "donaction-saas/**/*.svelte.js"
  - "!donaction-saas/node_modules/**"
---

# Svelte 5 Best Practices

## Runes & Reactivity

- Use `$state()` for reactive local state
- Use `$derived()` for computed values, not manual dependencies
- Use `$effect()` for side effects, cleanup in return function
- Use `$props()` to declare component props with TypeScript
- Use `$bindable()` for two-way prop binding
- Declare runes at top level, never in conditionals
- Prefer `$derived` over stores for computed values
- Use `.svelte.ts` files for universal reactivity outside components

```typescript
// Good - universal reactivity in .svelte.ts
const count = $state(0);
const double = $derived(count * 2);

export { count, double };
```

## Component Structure

- Order: `<svelte:options>`, `<script>`, markup, `<style>`
- Use `<script lang="ts">` for TypeScript support
- Use `async` attribute for top-level await
- Import lifecycle: `onMount`, `onDestroy`, `tick` from `svelte`
- Keep logic in separate `logic/` folder for complex components
- Use PascalCase for component filenames
- Export reactive state from `.svelte.ts` files, not `.svelte` components

```svelte
<svelte:options customElement={{tag: 'my-element'}} />

<script lang="ts">
  import { onMount } from 'svelte';

  let count = $state(0);
  let doubled = $derived(count * 2);
</script>

<button onclick={() => count++}>{doubled}</button>

<style lang="scss">
  button { padding: 1rem; }
</style>
```

## TypeScript Integration

- Always use `lang="ts"` in script tags
- Type props with explicit interface in `$props()`
- Type stores with generic: `writable<boolean>`
- Use `type` imports for type-only dependencies
- Export types from `.svelte.ts` files
- Avoid `any`, use `Record<string, unknown>` for objects
- Use discriminated unions for state machines

```typescript
// Good - typed props
let {
  animation,
  isControlled = false,
  goToFrame
}: {
  animation: JSON;
  isControlled?: boolean;
  goToFrame?: { value: number; cap: number };
} = $props();
```

## Web Components

- Use `<svelte:options customElement={{tag: 'custom-name'}} />`
- Kebab-case for tag names, no uppercase
- Use `dispatchEvent(new CustomEvent())` for custom events
- Set `bubbles: true, composed: true` for cross-shadow events
- Access shadow root via `querySelector('tag')?.shadowRoot`
- Prefix global event bus to avoid collisions
- Use slots for content projection

```svelte
<svelte:options customElement={{tag: 'klubr-form'}} />

<script lang="ts">
  const emit = () => {
    dispatchEvent(new CustomEvent('submit', {
      detail: { data },
      bubbles: true,
      composed: true
    }));
  };
</script>
```

## Reactivity Patterns

- Use `writable()` from `svelte/store` for cross-component state
- Subscribe to stores with `$` prefix or `.subscribe()`
- Call `tick()` before DOM queries after state updates
- Use `get()` to read store value without subscription
- Prefer runes over stores for local state
- Avoid manual `.set()` on `$state`, reassign directly
- Initialize mounted flag for tracking first subscription

```typescript
// Good - stores for cross-component state
import { writable, get } from 'svelte/store';

const index = writable<number>(0);
const isLoading = writable<boolean>(false);

// In component
$effect(() => {
  if (get(index) === 2) {
    isLoading.set(true);
  }
});
```

## Special Elements

- Use `<svelte:component>` for dynamic component rendering
- Use `<svelte:element>` for dynamic HTML elements
- Use `<svelte:window>` for window event listeners
- Use `<svelte:document>` for document-level events
- Use `<svelte:body>` for body element access
- Use `<svelte:head>` for meta tags, scripts
- Use `<svelte:boundary>` for error handling boundaries
- Cleanup listeners automatically on destroy

```svelte
<svelte:window on:resize={handleResize} />
<svelte:document on:click={handleClickOutside} />
```

## Performance

- Use `{#key}` for keyed each blocks with unique IDs
- Avoid deep reactivity, flatten state structure
- Use `$effect.pre()` for pre-render effects
- Debounce expensive operations in `$effect`
- Lazy load components with dynamic imports
- Use `bind:this` sparingly, prefer actions
- Avoid creating functions in templates

```svelte
{#each items as item (item.id)}
  <div>{item.name}</div>
{/each}
```

## Composition Patterns

- Use actions (`use:directive`) for DOM behavior
- Extract reusable actions to `utils/`
- Use snippets for template reuse (not components)
- Pass snippets to children via `@render` tag
- Use event bus for cross-component communication
- Separate business logic to `logic/` files
- Use `process.nextTick()` for async validation

```svelte
<script lang="ts">
  const swiperInstaller = (node: HTMLElement) => {
    // Setup logic
    return {
      destroy() {
        // Cleanup
      }
    };
  };
</script>

<swiper-container use:swiperInstaller />
```

## Styling

- Use `<style lang="scss">` for SCSS support
- Styles scoped by default, use `:global()` for global
- Use CSS variables for theming
- Use `@use` and `@forward` for SCSS modules
- Avoid inline styles, prefer classes
- Use Tailwind-like utility classes sparingly
- Component-specific styles in same file

```svelte
<style lang="scss">
  @use './index';

  button {
    padding: var(--spacing-md);
    color: var(--primary);
  }
</style>
```
