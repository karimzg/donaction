---
description: Next.js 14 Route Handlers (API Routes) patterns including request/response handling, middleware usage, authentication, CORS configuration, Edge vs Node runtime selection, and proxy patterns for backend communication.
globs: ["donaction-frontend/src/app/api/**/*.ts", "donaction-frontend/src/middleware.ts"]
alwaysApply: false
---

# Next.js 14 API Routes

## Route Handler Basics

- Create `route.ts` in `app/api` directory
- Export named functions: GET, POST, PUT, DELETE
- Return `Response` or `NextResponse` objects
- Access request via Request parameter
- Use TypeScript for type safety

```typescript
// app/api/revalidate/route.ts
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  const body = await request.json();
  // Handle request
  return NextResponse.json({ success: true });
}
```

## Request Handling

- Parse JSON with `await request.json()`
- Parse FormData with `await request.formData()`
- Access query params from `request.nextUrl.searchParams`
- Read cookies with `request.cookies.get()`
- Get headers with `request.headers.get()`

```typescript
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const id = searchParams.get('id');
  const token = request.cookies.get('token')?.value;

  return NextResponse.json({ id, token });
}
```

## Response Patterns

- Return JSON with `NextResponse.json(data)`
- Stream blobs with `NextResponse` constructor
- Set status with `{ status: 404 }`
- Set headers with `response.headers.set()`
- Set cookies with `response.cookies.set()`

```typescript
// @donaction-frontend/src/middleware.ts
const response = NextResponse.redirect(new URL('/connexion', request.url));
response.cookies.set('message', 'Please login', {
  path: '/',
  maxAge: 10 * 60,
});
return response;
```

## Dynamic Route Handlers

- Use `[param]` folders for dynamic segments
- Use `[...param]` for catch-all routes
- Access params from second argument
- Type params explicitly in TypeScript
- Handle multiple HTTP methods per route

```typescript
// app/api/[...fetch]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { fetch: string[] } }
) {
  const endpoint = params.fetch.join('/');
  // Proxy to backend
}
```

## Proxy Pattern

- Use catch-all route for backend proxy
- Rewrite paths before forwarding requests
- Switch tokens based on endpoint type
- Stream blob responses directly
- Add custom headers for backend

```typescript
// @donaction-frontend/src/app/api/[...fetch]/route.ts
export async function POST(request: Request, { params }) {
  const endpoint = params.fetch.join('/');

  // Rewrite auth paths
  const path = endpoint.replace('strapi-auth', 'auth');

  // Forward to Strapi backend
  const response = await fetch(`${API_URL}/api/${path}`, {
    method: 'POST',
    body: await request.text(),
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${TOKEN}`,
    },
  });

  return response;
}
```

## Authentication in Routes

- Use `getToken` from next-auth/jwt
- Check session before sensitive operations
- Return 401 for unauthorized requests
- Switch tokens for user vs system endpoints
- Validate JWT with jose library

```typescript
// @donaction-frontend/src/middleware.ts
import { getToken } from 'next-auth/jwt';

const token = await getToken({ req: request });
const isConnected = token && token?.jwt;

if (isProtectedAuth && !isConnected) {
  return NextResponse.redirect(new URL('/connexion', request.url));
}
```

## CORS Configuration

- Set CORS headers in route handlers
- Handle OPTIONS preflight requests
- Validate origin before setting headers
- Use middleware for global CORS rules
- Return 204 for OPTIONS method

```typescript
// @donaction-frontend/src/middleware.ts
if (request.method === 'OPTIONS') {
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': request.headers.get('origin'),
      'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}
```

## Middleware Configuration

- Create `middleware.ts` in src root
- Define path matchers for routes
- Use NextResponse for redirects and rewrites
- Access request headers and cookies
- Set custom headers on responses

```typescript
// @donaction-frontend/src/middleware.ts
export async function middleware(request: NextRequest) {
  const paths = {
    protected_auth: ['/profile', '/mes-dons'],
    protected_no_auth: ['/connexion', '/reset-password'],
    ignored: ['/_next', '/api', '/images'],
  };

  if (paths.ignored.some((_) => request.nextUrl.pathname.startsWith(_))) {
    return NextResponse.next();
  }

  // Auth logic
}
```

## Stripe Integration

- Create dedicated route for payment intents
- Use Stripe Node SDK on server side
- Validate request body before processing
- Return client_secret to frontend
- Never expose secret key to client

```typescript
// @donaction-frontend/src/app/api/create-payment-intent/route.ts
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

export async function POST(request: Request) {
  const { amount } = await request.json();

  const paymentIntent = await stripe.paymentIntents.create({
    amount: amount * 100, // Convert to cents
    currency: 'eur',
  });

  return NextResponse.json({ clientSecret: paymentIntent.client_secret });
}
```

## NextAuth Route Handler

- Use catch-all route for NextAuth callbacks
- Export GET and POST from same handler
- Configure providers in handler options
- Implement custom jwt and session callbacks
- Return handler as named exports

```typescript
// @donaction-frontend/src/app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import GoogleProvider from 'next-auth/providers/google';

const handler = NextAuth({
  providers: [
    GoogleProvider({
      clientId: process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID,
      clientSecret: process.env.NEXT_PUBLIC_GOOGLE_CLIENT_SECRET,
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user?.jwt) {
        token.jwt = user.jwt;
      }
      return token;
    },
  },
});

export { handler as GET, handler as POST };
```

## Edge vs Node Runtime

- Default runtime is Node.js
- Use Edge for lightweight operations
- Set with `export const runtime = 'edge'`
- Edge has limited Node.js APIs
- Node.js for complex operations (Stripe, databases)

```typescript
// Edge runtime example
export const runtime = 'edge';

export async function GET(request: Request) {
  // Lightweight operation
  return NextResponse.json({ message: 'Fast response' });
}
```

## Error Handling

- Try-catch around async operations
- Return appropriate status codes
- Include error messages in response
- Log errors for debugging
- Never expose sensitive error details

```typescript
export async function POST(request: Request) {
  try {
    const data = await processRequest(request);
    return NextResponse.json(data);
  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      { message: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

## Revalidation API Route

- Create dedicated route for on-demand revalidation
- Accept tag or path to revalidate
- Validate secret token before revalidating
- Call from CMS webhooks after content updates
- Return success response

```typescript
// @donaction-frontend/src/app/api/revalidate/route.ts
import { revalidatePath, revalidateTag } from 'next/cache';

export async function POST(request: Request) {
  const { tag, path, secret } = await request.json();

  // Validate secret
  if (secret !== process.env.REVALIDATE_SECRET) {
    return NextResponse.json({ message: 'Invalid secret' }, { status: 401 });
  }

  if (tag) revalidateTag(tag);
  if (path) revalidatePath(path);

  return NextResponse.json({ revalidated: true });
}
```
