---
description: Angular 21 standalone components using inject(), signals, modern control flow (@if, @for, @switch), and reactive patterns with takeUntilDestroyed() for building type-safe, reactive applications
globs:
  - "donaction-admin/**/*.component.ts"
  - "donaction-admin/**/*.service.ts"
  - "donaction-admin/**/*.directive.ts"
  - "donaction-admin/**/*.pipe.ts"
  - "!donaction-admin/node_modules/**"
---

# Angular 21 Core Patterns

## Component Structure

- Use standalone components always
- Declare `imports` in `@Component` decorator
- No NgModule except legacy integrations
- Selector prefix `app-` per workspace config

```typescript
@Component({
  selector: 'app-empty-page',
  imports: [LottieComponent, CommonModule],
  templateUrl: './empty-page.component.html'
})
export class EmptyPageComponent {}
```

## Dependency Injection

- Use `inject()` function exclusively
- Inject in component/service body, not constructor
- Private for internal dependencies
- Public only when used in template

```typescript
export class MyComponent {
  private router = inject(Router);
  public toastService = inject(ToastService); // Used in template
}
```

## Signals & Reactivity

- `signal()` for mutable state
- `computed()` for derived values
- `effect()` for side effects
- `input()` for component inputs
- `model()` for two-way binding
- `viewChild()` for view queries
- `output()` for event emitters

```typescript
export class MyComponent {
  count = signal(0);
  doubled = computed(() => this.count() * 2);
  title = input<string>('');
  value = model<number>(0);
  heading = viewChild<ElementRef>('title');
}
```

## Modern Control Flow

- Use `@if` instead of `*ngIf`
- Use `@for` instead of `*ngFor`
- Use `@switch` instead of `ngSwitch`
- Always track items with unique keys

```html
@if (title()) {
  <h1>{{ title() }}</h1>
}

@for (item of items(); track item.id) {
  <div>{{ item.name }}</div>
}

@switch (status()) {
  @case ('pending') { <p>Loading...</p> }
  @case ('success') { <p>Done!</p> }
  @default { <p>Unknown</p> }
}
```

## Reactive Programming

- `takeUntilDestroyed()` for subscription cleanup
- No manual `takeUntil(destroyed$)` pattern
- Place in pipe chain before subscribe
- Available in inject context only

```typescript
export class MyComponent {
  ngOnInit() {
    this.data$.pipe(
      takeUntilDestroyed()
    ).subscribe(data => {});
  }
}
```

## Lifecycle Hooks

- `ngOnInit` for initialization
- `ngAfterViewInit` for view access
- `ngOnDestroy` automatic with `takeUntilDestroyed()`
- Effects run automatically on signal changes

## Type Safety

- Strict TypeScript enabled
- Generic types for reusable components
- Interface/type for all data models
- No `any` unless absolutely necessary

```typescript
export class GenericUpdate<T extends EntityModel> {
  entity = signal<T | null>(null);
}
```
