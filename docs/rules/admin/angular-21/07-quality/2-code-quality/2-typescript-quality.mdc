---
description: TypeScript strict mode patterns, error handling, type safety, and performance best practices for Angular 21 applications with comprehensive typing and null safety
globs:
  - "donaction-admin/**/*.ts"
  - "!donaction-admin/node_modules/**"
---

# TypeScript Quality

## Strict Mode

- Enable all strict flags
- `strictNullChecks` for null safety
- `strictFunctionTypes` for parameters
- `noImplicitAny` for type inference
- No `any` type unless absolutely necessary

Reference config at @donaction-admin/tsconfig.json

## Type Definitions

- Interface for object shapes
- Type for unions and intersections
- Generic types for reusable code
- Exported from model files

```typescript
export interface User {
  id: string;
  email: string;
  role: 'admin' | 'user';
}

export type ApiResponse<T> = {
  data: T;
  meta: { total: number };
};
```

## Null Safety

- Use `null` or `undefined` explicitly
- Optional chaining `?.` for access
- Nullish coalescing `??` for defaults
- Type guards for narrowing

```typescript
function getUser(id: string | null): User | null {
  if (!id) return null;
  return users.find(u => u.id === id) ?? null;
}

const name = user?.profile?.name ?? 'Unknown';
```

## Error Handling

- Always handle errors explicitly
- Type errors with custom classes
- Never silent catch blocks
- Log errors for debugging
- Show user-friendly messages

```typescript
try {
  const data = await api.fetchData();
  this.data.set(data);
} catch (error) {
  console.error('Failed to fetch data:', error);
  this.toastService.showError('Could not load data');
  this.error.set(error instanceof Error ? error.message : 'Unknown error');
}
```

## Type Guards

- Create type predicates
- Narrow union types
- Runtime type checking
- Use `instanceof` and `typeof`

```typescript
function isUser(obj: unknown): obj is User {
  return typeof obj === 'object' && obj !== null && 'email' in obj;
}

if (isUser(data)) {
  console.log(data.email); // Type-safe
}
```

## Generics

- Reusable component types
- Constrain with `extends`
- Default type parameters
- Inferred types when possible

```typescript
export class GenericList<T extends { id: string }> {
  items = signal<T[]>([]);

  findById(id: string): T | undefined {
    return this.items().find(item => item.id === id);
  }
}
```

## Performance

- Avoid unnecessary object creation
- Use `trackBy` for `@for` loops
- Memoize computed values
- Lazy load heavy modules
- Unsubscribe from observables

```typescript
trackByFn(index: number, item: { id: string }) {
  return item.id;
}
```

```html
@for (item of items(); track item.id) {
  <div>{{ item.name }}</div>
}
```

## Immutability

- Prefer `readonly` for arrays/objects
- Update signals, don't mutate
- Use spread operator for copies
- Freeze objects in dev mode

```typescript
const config: Readonly<Config> = { apiUrl: '...' };

const newArray = [...this.items(), newItem]; // Don't push
this.items.set(newArray);
```

## Code Organization

- One export per file for components
- Group related types in model files
- Barrel exports from folders
- Clear file naming conventions

Reference structure at @donaction-admin/src/app/shared/utils/models/
