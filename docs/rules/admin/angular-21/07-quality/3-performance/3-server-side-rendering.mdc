---
description: Server-Side Rendering and hydration with provideClientHydration, hybrid rendering modes, performance optimization, and SSR best practices for Angular 21 applications
globs:
  - "donaction-admin/**/*.config.ts"
  - "donaction-admin/**/*.routes.ts"
  - "donaction-admin/**/app.config.server.ts"
  - "!donaction-admin/node_modules/**"
---

# Server-Side Rendering

## Setup

### New Project

```bash
ng new my-app --ssr
```

### Existing Project

```bash
ng add @angular/ssr
```

## Enable Hydration

- Import from `@angular/platform-browser`
- Add to client bootstrap providers
- Must also provide on server
- Enable features with functions

```typescript
// app.config.ts
import { provideClientHydration, withEventReplay } from '@angular/platform-browser';

export const appConfig: ApplicationConfig = {
  providers: [
    provideClientHydration(
      withEventReplay(),
      withI18nSupport()
    )
  ]
};
```

```typescript
// app.config.server.ts
import { provideClientHydration } from '@angular/platform-browser';

export const serverConfig: ApplicationConfig = {
  providers: [
    provideClientHydration()
  ]
};
```

## Hybrid Rendering Modes

### Route Configuration

```typescript
// app.routes.server.ts
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  { path: '', renderMode: RenderMode.Prerender },
  { path: 'about', renderMode: RenderMode.Prerender },
  { path: 'profile/:id', renderMode: RenderMode.Server },
  { path: 'admin', renderMode: RenderMode.Client }
];
```

### Register Server Routes

```typescript
// app.config.server.ts
import { provideServerRendering, withRoutes } from '@angular/ssr';
import { serverRoutes } from './app.routes.server';

export const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering(withRoutes(serverRoutes))
  ]
};
```

### Render Modes

| Mode | When | Use Case |
|------|------|----------|
| `Prerender` | Build time | Static content, marketing pages |
| `Server` | Per request | Dynamic data, authenticated routes |
| `Client` | Browser only | Heavy interactivity, browser APIs |

## Static Output

```json
// angular.json
{
  "projects": {
    "my-app": {
      "architect": {
        "build": {
          "options": {
            "outputMode": "static"
          }
        }
      }
    }
  }
}
```

## Avoid Browser APIs

### Use Lifecycle Hooks

```typescript
export class MyComponent {
  constructor() {
    afterNextRender(() => {
      // Browser-only code
      window.analytics.track('page_view');
    });
  }
}
```

### Platform-Specific Services

```typescript
// analytics.service.ts
export abstract class AnalyticsService {
  abstract track(event: string): void;
}

// analytics.browser.ts
@Injectable()
export class BrowserAnalyticsService extends AnalyticsService {
  track(event: string) {
    window.gtag('event', event);
  }
}

// analytics.server.ts
@Injectable()
export class ServerAnalyticsService extends AnalyticsService {
  track(event: string) {
    // No-op or log to server
  }
}
```

```typescript
// app.config.ts
providers: [
  { provide: AnalyticsService, useClass: BrowserAnalyticsService }
]

// app.config.server.ts
providers: [
  { provide: AnalyticsService, useClass: ServerAnalyticsService }
]
```

### Injection Tokens

```typescript
import { DOCUMENT } from '@angular/common';
import { isPlatformBrowser } from '@angular/common';
import { PLATFORM_ID } from '@angular/core';

export class MyComponent {
  private document = inject(DOCUMENT);
  private platformId = inject(PLATFORM_ID);

  ngOnInit() {
    if (isPlatformBrowser(this.platformId)) {
      this.document.querySelector('.my-element');
    }
  }
}
```

## HTTP Transfer Cache

- Automatic for GET/HEAD requests
- Prevents duplicate server/client calls
- Configure via `withHttpTransferCacheOptions()`

```typescript
provideClientHydration(
  withHttpTransferCacheOptions({
    includePostRequests: true,
    filter: (req) => !req.url.includes('sensitive')
  })
)
```

## Hydration Best Practices

### DOM Structure Consistency

- Server HTML must match client exactly
- Includes whitespace and comments
- No direct DOM manipulation
- Avoid `innerHTML`, `appendChild`

### Valid HTML

- Explicitly declare `<tbody>` in tables
- No `<div>` inside `<p>`
- No nested `<a>` elements
- Close all tags properly

```html
<!-- Bad -->
<table>
  <tr><td>Data</td></tr>
</table>

<!-- Good -->
<table>
  <tbody>
    <tr><td>Data</td></tr>
  </tbody>
</table>
```

### Event Replay

- Captures user interactions before hydration
- Prevents lost clicks/inputs
- Enable with `withEventReplay()`

```typescript
provideClientHydration(
  withEventReplay()
)
```

### Skip Hydration Selectively

- Use `ngSkipHydration` as last resort
- Temporary workaround for third-party components
- Should be exceptional, not common

```html
<app-third-party-map ngSkipHydration />
```

### I18n Support

```typescript
provideClientHydration(
  withI18nSupport()
)
```

### Third-Party Scripts

- Defer until after hydration
- Use `afterNextRender()` lifecycle
- Prevent DOM manipulation conflicts

```typescript
afterNextRender(() => {
  const script = this.document.createElement('script');
  script.src = 'https://analytics.example.com/track.js';
  this.document.head.appendChild(script);
});
```

## Server APIs

### Access Request/Response

```typescript
import { REQUEST, RESPONSE_INIT } from '@angular/ssr/tokens';

export class MyComponent {
  private request = inject(REQUEST, { optional: true });
  private responseInit = inject(RESPONSE_INIT, { optional: true });

  ngOnInit() {
    if (this.request) {
      const userAgent = this.request.headers.get('user-agent');
    }

    if (this.responseInit) {
      this.responseInit.headers = {
        'Cache-Control': 'public, max-age=3600'
      };
    }
  }
}
```

### Prerender Params

```typescript
// app.routes.server.ts
import { getPrerenderParams } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
  {
    path: 'product/:id',
    renderMode: RenderMode.Prerender,
    async getPrerenderParams() {
      const products = await fetch('/api/products').then(r => r.json());
      return products.map((p: Product) => ({ id: p.id }));
    }
  }
];
```

## Performance Optimization

### Incremental Hydration

- Defer hydration for non-critical components
- Hydrate on interaction or viewport
- Improve TTI (Time to Interactive)

```typescript
import { withIncrementalHydration } from '@angular/platform-browser';

provideClientHydration(
  withIncrementalHydration()
)
```

### Defer Loading

```html
@defer (on viewport) {
  <app-heavy-component />
} @placeholder {
  <div>Loading...</div>
}
```

### Critical CSS

- Inline critical CSS
- Defer non-critical styles
- Reduce render-blocking resources

## Debugging

### Check Hydration

- Open browser DevTools console
- Look for "hydration stats" message
- Shows components/nodes hydrated

### Angular DevTools

- Install Angular DevTools extension
- Visualize hydrated sections
- Identify mismatch errors

### Common Issues

**Hydration Mismatch:**
- Check whitespace settings match
- Verify server/client render same HTML
- Inspect conditional rendering

**Browser API Errors:**
- Move to `afterNextRender()`
- Use platform checks
- Provide server alternatives

**Third-Party Conflicts:**
- Use `ngSkipHydration`
- Defer script loading
- Check library SSR support

## Best Practices Summary

- Enable hydration for all SSR apps
- Use `afterNextRender()` for browser APIs
- Configure render modes per route
- Avoid direct DOM manipulation
- Write valid HTML
- Test with DevTools
- Enable event replay
- Defer third-party scripts
- Use HTTP transfer cache
- Monitor Core Web Vitals

References:
- [Angular SSR Guide](https://angular.dev/guide/ssr)
- [Hydration](https://angular.dev/guide/hydration)
- [Incremental Hydration](https://angular.dev/guide/incremental-hydration)
- [Performance Guide](https://angular.dev/guide/performance)
