name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      confirmation:
        description: 'Type DEPLOY-PROD to confirm deployment'
        required: true
        type: string
      skip_staging:
        description: 'Skip staging deployment (for urgent hotfixes)'
        required: false
        default: false
        type: boolean
      version_tag:
        description: 'Version tag (e.g., v1.2.3)'
        required: true
        type: string
      apps:
        description: 'Apps to deploy (comma-separated: frontend,api,admin,saas or "all")'
        required: false
        default: 'all'
        type: string
      image_tag:
        description: 'Image tag to deploy (default: prod, or use sha-xxxxx/vX.Y.Z for specific version)'
        required: false
        default: ''
        type: string

concurrency:
  group: deploy-production
  cancel-in-progress: false

permissions:
  contents: write
  packages: read

env:
  PROD_DOMAIN: www.donaction.fr
  PROD_ENV: prod
  STAGING_DOMAIN: re7.donaction.fr
  STAGING_ENV: re7
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  SSH_PORT: 63009
  DEPLOY_DIR_PROD: ~/donaction-production
  DEPLOY_DIR_STAGING: ~/donaction-staging

jobs:
  validate:
    name: Validate Deployment Request
    runs-on: ubuntu-latest
    outputs:
      deploy_frontend: ${{ steps.apps.outputs.frontend }}
      deploy_api: ${{ steps.apps.outputs.api }}
      deploy_admin: ${{ steps.apps.outputs.admin }}
      deploy_saas: ${{ steps.apps.outputs.saas }}
      services_list: ${{ steps.apps.outputs.services_list }}
      version: ${{ steps.version.outputs.version }}
      image_tag: ${{ steps.image.outputs.tag }}
    steps:
      - name: Validate confirmation
        if: github.event.inputs.confirmation != 'DEPLOY-PROD'
        run: |
          echo "::error::Confirmation failed. You must type 'DEPLOY-PROD' to proceed."
          exit 1

      - name: Determine image tag
        id: image
        run: |
          INPUT_TAG="${{ github.event.inputs.image_tag }}"
          if [[ -z "$INPUT_TAG" ]]; then
            echo "tag=prod" >> $GITHUB_OUTPUT
          else
            echo "tag=$INPUT_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Validate branch
        run: |
          BRANCH="${{ github.ref_name }}"
          if [[ ! "$BRANCH" =~ ^(release/|hotfix/) ]]; then
            echo "::error::Production deployment only allowed from release/* or hotfix/* branches. Current: $BRANCH"
            exit 1
          fi

      - name: Validate version tag
        id: version
        run: |
          VERSION="${{ github.event.inputs.version_tag }}"
          BRANCH="${{ github.ref_name }}"

          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid version tag format. Expected: vX.Y.Z (e.g., v1.2.3)"
            exit 1
          fi

          if [[ "$BRANCH" =~ ^(release|hotfix)/(v[0-9]+\.[0-9]+\.[0-9]+) ]]; then
            BRANCH_VERSION="${BASH_REMATCH[2]}"
            if [[ "$VERSION" != "$BRANCH_VERSION" ]]; then
              echo "::error::Version tag mismatch! Input: $VERSION, Branch: $BRANCH_VERSION"
              exit 1
            fi
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Determine apps to deploy
        id: apps
        run: |
          APPS="${{ github.event.inputs.apps }}"
          SERVICES=""

          VALID_APPS="frontend api admin saas all"
          for APP in ${APPS//,/ }; do
            if [[ ! " $VALID_APPS " =~ " $APP " ]]; then
              echo "::error::Invalid app name: '$APP'. Allowed values: $VALID_APPS"
              exit 1
            fi
          done

          if [[ "$APPS" == "all" ]]; then
            echo "frontend=true" >> $GITHUB_OUTPUT
            echo "api=true" >> $GITHUB_OUTPUT
            echo "admin=true" >> $GITHUB_OUTPUT
            echo "saas=true" >> $GITHUB_OUTPUT
            SERVICES="frontend api admin saas"
          else
            [[ "$APPS" == *"frontend"* ]] && echo "frontend=true" >> $GITHUB_OUTPUT && SERVICES="$SERVICES frontend" || echo "frontend=false" >> $GITHUB_OUTPUT
            [[ "$APPS" == *"api"* ]] && echo "api=true" >> $GITHUB_OUTPUT && SERVICES="$SERVICES api" || echo "api=false" >> $GITHUB_OUTPUT
            [[ "$APPS" == *"admin"* ]] && echo "admin=true" >> $GITHUB_OUTPUT && SERVICES="$SERVICES admin" || echo "admin=false" >> $GITHUB_OUTPUT
            [[ "$APPS" == *"saas"* ]] && echo "saas=true" >> $GITHUB_OUTPUT && SERVICES="$SERVICES saas" || echo "saas=false" >> $GITHUB_OUTPUT
          fi

          echo "services_list=${SERVICES}" >> $GITHUB_OUTPUT

  deploy-staging:
    name: Deploy to Staging First
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.skip_staging != 'true'
    environment: staging
    timeout-minutes: 15
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: ./.github/actions/ssh-setup
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
          ssh-host: ${{ vars.SSH_HOST }}
          ssh-user: ${{ vars.SSH_USER }}
          ssh-port: ${{ env.SSH_PORT }}

      - name: Validate secrets
        uses: ./.github/actions/validate-secrets
        with:
          secrets: |
            SSH_USER:${{ vars.SSH_USER }}
            SSH_HOST:${{ vars.SSH_HOST }}
            DATABASE_HOST:${{ vars.DATABASE_HOST }}
            DATABASE_NAME:${{ vars.DATABASE_NAME }}
            DATABASE_USERNAME:${{ secrets.DATABASE_USERNAME }}
            DATABASE_PASSWORD:${{ secrets.DATABASE_PASSWORD }}
            JWT_SECRET:${{ secrets.JWT_SECRET }}
            ADMIN_JWT_SECRET:${{ secrets.ADMIN_JWT_SECRET }}
            APP_KEYS:${{ secrets.APP_KEYS }}
            API_TOKEN_SALT:${{ secrets.API_TOKEN_SALT }}
            TRANSFER_TOKEN_SALT:${{ secrets.TRANSFER_TOKEN_SALT }}
            STRIPE_SECRET_KEY:${{ secrets.STRIPE_SECRET_KEY }}
            NEXTAUTH_SECRET:${{ secrets.NEXTAUTH_SECRET }}
            KLUBR_UUID:${{ vars.KLUBR_UUID }}

      - name: Validate Docker Compose v2
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            if ! docker compose version --short 2>/dev/null | grep -qE '^2\.'; then
              echo "::error::Docker Compose v2 required"
              exit 1
            fi
          EOF

      - name: Create deployment directory
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            mkdir -p ~/donaction-staging/{nginx,backups,logs,data/pgdata,data/private-pdf}
          EOF

      - name: Copy deployment files
        run: |
          scp -P ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa \
            infrastructure/staging/docker-compose.yml \
            ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }}:${{ env.DEPLOY_DIR_STAGING }}/

          scp -P ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa \
            infrastructure/staging/nginx/donaction.conf \
            ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }}:${{ env.DEPLOY_DIR_STAGING }}/nginx/

      - name: Generate and copy .env file
        run: |
          export DEPLOY_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          export GITHUB_REF_NAME="${{ github.ref_name }}"
          export GITHUB_SHA="${{ github.sha }}"
          export DOMAIN="${{ env.STAGING_DOMAIN }}"
          export DATABASE_HOST="${{ vars.DATABASE_HOST }}"
          export DATABASE_PORT="${{ vars.DATABASE_PORT }}"
          export DATABASE_NAME="${{ vars.DATABASE_NAME }}"
          export DATABASE_USERNAME="${{ secrets.DATABASE_USERNAME }}"
          export DATABASE_PASSWORD="${{ secrets.DATABASE_PASSWORD }}"
          export DATABASE_SSL="${{ vars.DATABASE_SSL }}"
          export JWT_SECRET="${{ secrets.JWT_SECRET }}"
          export ADMIN_JWT_SECRET="${{ secrets.ADMIN_JWT_SECRET }}"
          export APP_KEYS="${{ secrets.APP_KEYS }}"
          export API_TOKEN_SALT="${{ secrets.API_TOKEN_SALT }}"
          export TRANSFER_TOKEN_SALT="${{ secrets.TRANSFER_TOKEN_SALT }}"
          export STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}"
          export STRIPE_WEBHOOK_SECRET="${{ secrets.STRIPE_WEBHOOK_SECRET }}"
          export STRIPE_WEBHOOK_SECRET_CONNECT="${{ secrets.STRIPE_WEBHOOK_SECRET_CONNECT }}"
          export IMAGEKIT_PUBLIC_KEY="${{ secrets.IMAGEKIT_PUBLIC_KEY }}"
          export IMAGEKIT_PRIVATE_KEY="${{ secrets.IMAGEKIT_PRIVATE_KEY }}"
          export IMAGEKIT_URL_ENDPOINT="${{ vars.IMAGEKIT_URL_ENDPOINT }}"
          export BREVO_API_KEY="${{ secrets.BREVO_API_KEY }}"
          export GOOGLE_RECAPTCHA_SITE_KEY="${{ secrets.GOOGLE_RECAPTCHA_SITE_KEY }}"
          export GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}"
          export GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}"
          export GOOGLE_MAPS_API_KEY="${{ secrets.GOOGLE_MAPS_API_KEY }}"
          export GOOGLE_GA_TRACKING_ID="${{ secrets.GOOGLE_GA_TRACKING_ID }}"
          export GOOGLE_PROJECT_NUMBER="${{ vars.GOOGLE_PROJECT_NUMBER }}"
          export GOOGLE_API_KEY_ID="${{ vars.GOOGLE_API_KEY_ID }}"
          export GOOGLE_PROJECT_ID="${{ vars.GOOGLE_PROJECT_ID }}"
          export FRONT_URL="${{ vars.FRONT_URL }}"
          export NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}"
          export KLUBR_UUID="${{ vars.KLUBR_UUID }}"
          export STRAPI_FRONT_API_TOKEN="${{ secrets.STRAPI_FRONT_API_TOKEN }}"
          export STRIPE_PUBLIC_KEY="${{ secrets.STRIPE_PUBLIC_KEY }}"
          export VITE_ACTIVATE_ANALYTICS="${{ vars.VITE_ACTIVATE_ANALYTICS }}"
          export PLAUSIBLE_DATA_DOMAIN="${{ vars.PLAUSIBLE_DATA_DOMAIN }}"

          envsubst < .github/templates/env.staging.template > /tmp/.env.staging

          ENV_BASE64=$(cat /tmp/.env.staging | base64 -w 0)
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} \
            "echo '$ENV_BASE64' | base64 -d > ${{ env.DEPLOY_DIR_STAGING }}/.env && chmod 600 ${{ env.DEPLOY_DIR_STAGING }}/.env"

      - name: Login to GHCR on server
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} \
            "docker login ghcr.io -u ${{ github.actor }} --password-stdin"

      - name: Deploy containers
        uses: ./.github/actions/deploy-containers
        with:
          ssh-user: ${{ vars.SSH_USER }}
          ssh-host: ${{ vars.SSH_HOST }}
          ssh-port: ${{ env.SSH_PORT }}
          deploy-dir: ${{ env.DEPLOY_DIR_STAGING }}
          services-list: ${{ needs.validate.outputs.services_list }}
          image-tag: dev
          image-registry: ${{ env.IMAGE_REGISTRY }}
          run-migrations: 'false'

      - name: Install and reload nginx
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            sudo cp ~/donaction-staging/nginx/donaction.conf /etc/nginx/sites-available/donaction-staging.conf
            sudo ln -sf /etc/nginx/sites-available/donaction-staging.conf /etc/nginx/sites-enabled/
            sudo nginx -t && sudo systemctl reload nginx
          EOF

      - name: Health check staging
        run: |
          MAX_RETRIES=5
          RETRY_DELAY=10
          for i in $(seq 1 $MAX_RETRIES); do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.STAGING_DOMAIN }}/health || echo "000")
            if [[ "$HTTP_STATUS" == "200" ]]; then
              echo "Staging health check passed"
              exit 0
            fi
            echo "Attempt $i/$MAX_RETRIES - Status: $HTTP_STATUS. Retrying..."
            sleep $RETRY_DELAY
          done
          echo "::error::Staging health check failed"
          exit 1

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/id_rsa

  validate-staging:
    name: Validate Staging Deployment
    runs-on: ubuntu-latest
    needs: [validate, deploy-staging]
    if: github.event.inputs.skip_staging != 'true'
    steps:
      - name: Final staging health check
        run: |
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.STAGING_DOMAIN }}/health)
          if [[ "$HTTP_STATUS" != "200" ]]; then
            echo "::error::Staging health check failed: $HTTP_STATUS"
            exit 1
          fi
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.STAGING_DOMAIN }}/service/health)
          if [[ "$API_STATUS" != "200" ]]; then
            echo "::warning::API health check returned: $API_STATUS"
          fi
          echo "Staging validation complete"

  deploy-production:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: [validate, validate-staging]
    if: always() && needs.validate.result == 'success' && (needs.validate-staging.result == 'success' || needs.validate-staging.result == 'skipped')
    environment:
      name: production
    timeout-minutes: 20
    outputs:
      deployment_time: ${{ steps.deploy.outputs.deployment_time }}
      service_status: ${{ steps.health.outputs.service-status }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: ./.github/actions/ssh-setup
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
          ssh-host: ${{ vars.SSH_HOST }}
          ssh-user: ${{ vars.SSH_USER }}
          ssh-port: ${{ env.SSH_PORT }}

      - name: Validate secrets
        uses: ./.github/actions/validate-secrets
        with:
          secrets: |
            SSH_USER:${{ vars.SSH_USER }}
            SSH_HOST:${{ vars.SSH_HOST }}
            DATABASE_HOST:${{ vars.DATABASE_HOST }}
            DATABASE_NAME:${{ vars.DATABASE_NAME }}
            DATABASE_USERNAME:${{ secrets.DATABASE_USERNAME }}
            DATABASE_PASSWORD:${{ secrets.DATABASE_PASSWORD }}
            JWT_SECRET:${{ secrets.JWT_SECRET }}
            ADMIN_JWT_SECRET:${{ secrets.ADMIN_JWT_SECRET }}
            APP_KEYS:${{ secrets.APP_KEYS }}
            API_TOKEN_SALT:${{ secrets.API_TOKEN_SALT }}
            TRANSFER_TOKEN_SALT:${{ secrets.TRANSFER_TOKEN_SALT }}
            STRIPE_SECRET_KEY:${{ secrets.STRIPE_SECRET_KEY }}
            NEXTAUTH_SECRET:${{ secrets.NEXTAUTH_SECRET }}
            KLUBR_UUID:${{ vars.KLUBR_UUID }}

      - name: Validate Docker Compose v2
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            if ! docker compose version --short 2>/dev/null | grep -qE '^2\.'; then
              echo "::error::Docker Compose v2 required"
              exit 1
            fi
          EOF

      - name: Check port availability
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            PORTS="3100 1537 4300 5100 5532"
            BLOCKED=""
            for PORT in $PORTS; do
              PID=$(sudo lsof -t -i:$PORT 2>/dev/null | head -1)
              if [[ -n "$PID" ]]; then
                PROCESS=$(ps -p $PID -o comm= 2>/dev/null)
                if [[ "$PROCESS" != "docker"* ]] && ! docker ps --format '{{.Ports}}' | grep -qE ":${PORT}->|:${PORT}/"; then
                  BLOCKED="$BLOCKED $PORT(used by $PROCESS)"
                fi
              fi
            done
            if [[ -n "$BLOCKED" ]]; then
              echo "::error::Ports blocked:$BLOCKED"
              exit 1
            fi
          EOF

      - name: Check SSL certificate
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            CERT_PATH="/etc/letsencrypt/live/www.donaction.fr"
            if [[ ! -f "$CERT_PATH/fullchain.pem" ]] || [[ ! -f "$CERT_PATH/privkey.pem" ]]; then
              echo "::error::SSL certificate files not found"
              exit 1
            fi
          EOF

          CERT_INFO=$(echo | openssl s_client -servername ${{ env.PROD_DOMAIN }} \
            -connect ${{ env.PROD_DOMAIN }}:443 2>/dev/null | \
            openssl x509 -noout -enddate 2>/dev/null) || true

          if [[ -n "$CERT_INFO" ]]; then
            EXPIRY=$(echo "$CERT_INFO" | cut -d= -f2)
            if EXPIRY_EPOCH=$(date -d "$EXPIRY" +%s 2>/dev/null); then
              NOW_EPOCH=$(date +%s)
              DAYS_LEFT=$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))
              if [[ $DAYS_LEFT -lt 7 ]]; then
                echo "::error::SSL certificate expires in $DAYS_LEFT days!"
                exit 1
              fi
            fi
          fi

      - name: Verify disk space
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            AVAILABLE=$(df -BG /home | tail -1 | awk '{print $4}' | sed 's/G//')
            if [[ $AVAILABLE -lt 5 ]]; then
              echo "::error::Insufficient disk space: ${AVAILABLE}GB (minimum 5GB)"
              exit 1
            fi
          EOF

      - name: Create deployment directory
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            mkdir -p ~/donaction-production/{nginx,backups,logs,data/pgdata,data/private-pdf}
          EOF

      - name: Copy deployment files
        run: |
          scp -P ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa \
            infrastructure/production/docker-compose.yml \
            ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }}:${{ env.DEPLOY_DIR_PROD }}/

          scp -P ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa \
            infrastructure/production/nginx/donaction.conf \
            ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }}:${{ env.DEPLOY_DIR_PROD }}/nginx/

      - name: Generate and copy .env file
        run: |
          export DEPLOY_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          export GITHUB_REF_NAME="${{ github.ref_name }}"
          export GITHUB_SHA="${{ github.sha }}"
          export VERSION="${{ needs.validate.outputs.version }}"
          export DOMAIN="${{ env.PROD_DOMAIN }}"
          export DATABASE_HOST="${{ vars.DATABASE_HOST }}"
          export DATABASE_PORT="${{ vars.DATABASE_PORT }}"
          export DATABASE_NAME="${{ vars.DATABASE_NAME }}"
          export DATABASE_USERNAME="${{ secrets.DATABASE_USERNAME }}"
          export DATABASE_PASSWORD="${{ secrets.DATABASE_PASSWORD }}"
          export DATABASE_SSL="${{ vars.DATABASE_SSL }}"
          export JWT_SECRET="${{ secrets.JWT_SECRET }}"
          export ADMIN_JWT_SECRET="${{ secrets.ADMIN_JWT_SECRET }}"
          export APP_KEYS="${{ secrets.APP_KEYS }}"
          export API_TOKEN_SALT="${{ secrets.API_TOKEN_SALT }}"
          export TRANSFER_TOKEN_SALT="${{ secrets.TRANSFER_TOKEN_SALT }}"
          export STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}"
          export STRIPE_WEBHOOK_SECRET="${{ secrets.STRIPE_WEBHOOK_SECRET }}"
          export STRIPE_WEBHOOK_SECRET_CONNECT="${{ secrets.STRIPE_WEBHOOK_SECRET_CONNECT }}"
          export IMAGEKIT_PUBLIC_KEY="${{ secrets.IMAGEKIT_PUBLIC_KEY }}"
          export IMAGEKIT_PRIVATE_KEY="${{ secrets.IMAGEKIT_PRIVATE_KEY }}"
          export IMAGEKIT_URL_ENDPOINT="${{ vars.IMAGEKIT_URL_ENDPOINT }}"
          export BREVO_API_KEY="${{ secrets.BREVO_API_KEY }}"
          export GOOGLE_RECAPTCHA_SITE_KEY="${{ secrets.GOOGLE_RECAPTCHA_SITE_KEY }}"
          export GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}"
          export GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}"
          export GOOGLE_MAPS_API_KEY="${{ secrets.GOOGLE_MAPS_API_KEY }}"
          export GOOGLE_GA_TRACKING_ID="${{ secrets.GOOGLE_GA_TRACKING_ID }}"
          export GOOGLE_PROJECT_NUMBER="${{ vars.GOOGLE_PROJECT_NUMBER }}"
          export GOOGLE_API_KEY_ID="${{ vars.GOOGLE_API_KEY_ID }}"
          export GOOGLE_PROJECT_ID="${{ vars.GOOGLE_PROJECT_ID }}"
          export FRONT_URL="${{ vars.FRONT_URL }}"
          export NEXTAUTH_SECRET="${{ secrets.NEXTAUTH_SECRET }}"
          export KLUBR_UUID="${{ vars.KLUBR_UUID }}"
          export STRAPI_FRONT_API_TOKEN="${{ secrets.STRAPI_FRONT_API_TOKEN }}"
          export STRIPE_PUBLIC_KEY="${{ secrets.STRIPE_PUBLIC_KEY }}"
          export VITE_ACTIVATE_ANALYTICS="${{ vars.VITE_ACTIVATE_ANALYTICS }}"
          export PLAUSIBLE_DATA_DOMAIN="${{ vars.PLAUSIBLE_DATA_DOMAIN }}"

          envsubst < .github/templates/env.production.template > /tmp/.env.production

          ENV_BASE64=$(cat /tmp/.env.production | base64 -w 0)
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} \
            "echo '$ENV_BASE64' | base64 -d > ${{ env.DEPLOY_DIR_PROD }}/.env && chmod 600 ${{ env.DEPLOY_DIR_PROD }}/.env"

      - name: Login to GHCR on server
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} \
            "docker login ghcr.io -u ${{ github.actor }} --password-stdin"

      - name: Verify images exist in registry
        run: |
          SERVICES="${{ needs.validate.outputs.services_list }}"
          IMAGE_TAG="${{ needs.validate.outputs.image_tag }}"
          APPS_TO_CHECK="${SERVICES:-frontend api admin saas}"
          FAILED=""

          for APP in $APPS_TO_CHECK; do
            IMAGE="ghcr.io/karimzg/donaction-${APP}:${IMAGE_TAG}"
            if ! docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              FAILED="$FAILED $APP"
            fi
          done

          if [[ -n "$FAILED" ]]; then
            echo "::error::Missing images:$FAILED (tag: ${IMAGE_TAG})"
            exit 1
          fi

      - name: Deploy containers
        id: deploy
        uses: ./.github/actions/deploy-containers
        with:
          ssh-user: ${{ vars.SSH_USER }}
          ssh-host: ${{ vars.SSH_HOST }}
          ssh-port: ${{ env.SSH_PORT }}
          deploy-dir: ${{ env.DEPLOY_DIR_PROD }}
          services-list: ${{ needs.validate.outputs.services_list }}
          image-tag: ${{ needs.validate.outputs.image_tag }}
          image-registry: ${{ env.IMAGE_REGISTRY }}
          run-migrations: ${{ contains(needs.validate.outputs.services_list, 'api') || needs.validate.outputs.services_list == '' }}

      - name: Write deployment log
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            cd ~/donaction-production
            LOG_FILE="logs/deployments.log"
            echo "---" >> "$LOG_FILE"
            echo "timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$LOG_FILE"
            echo "branch: ${{ github.ref_name }}" >> "$LOG_FILE"
            echo "commit: ${{ github.sha }}" >> "$LOG_FILE"
            echo "version: ${{ needs.validate.outputs.version }}" >> "$LOG_FILE"
            echo "actor: ${{ github.actor }}" >> "$LOG_FILE"
            echo "run_id: ${{ github.run_id }}" >> "$LOG_FILE"
            echo "services: ${{ needs.validate.outputs.services_list }}" >> "$LOG_FILE"
            echo "images:" >> "$LOG_FILE"
            docker compose config --images | sed 's/^/  - /' >> "$LOG_FILE"
          EOF

      - name: Install and reload nginx
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'
            sudo cp ~/donaction-production/nginx/donaction.conf /etc/nginx/sites-available/donaction-production.conf
            sudo ln -sf /etc/nginx/sites-available/donaction-production.conf /etc/nginx/sites-enabled/
            sudo nginx -t && sudo systemctl reload nginx
          EOF

      - name: Health check
        id: health
        uses: ./.github/actions/health-check
        with:
          ssh-user: ${{ vars.SSH_USER }}
          ssh-host: ${{ vars.SSH_HOST }}
          ssh-port: ${{ env.SSH_PORT }}
          domain: ${{ env.PROD_DOMAIN }}

      - name: Rollback on failure
        if: failure() && steps.deploy.outcome == 'success'
        uses: ./.github/actions/rollback
        with:
          ssh-user: ${{ vars.SSH_USER }}
          ssh-host: ${{ vars.SSH_HOST }}
          ssh-port: ${{ env.SSH_PORT }}
          deploy-dir: ${{ env.DEPLOY_DIR_PROD }}
          github-run-id: ${{ github.run_id }}

      - name: Notify rollback
        if: failure() && steps.deploy.outcome == 'success'
        uses: ./.github/actions/notify
        with:
          mode: rollback
          environment-name: Production
          domain: ${{ env.PROD_DOMAIN }}
          deployed-by: ${{ github.actor }}
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          discord-webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          github-ref-name: ${{ github.ref_name }}
          github-sha: ${{ github.sha }}
          github-server-url: ${{ github.server_url }}
          github-repository: ${{ github.repository }}
          github-run-id: ${{ github.run_id }}

      - name: Create rollback issue as fallback
        if: failure() && steps.deploy.outcome == 'success'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸš¨ Production Rollback - ${{ github.ref_name }}',
              body: `## Production Deployment Rolled Back\n\n**Environment:** Production (${{ env.PROD_DOMAIN }})\n**Branch:** ${{ github.ref_name }}\n**Triggered by:** @${{ github.actor }}\n**Run:** [View Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`,
              labels: ['production', 'rollback', 'urgent']
            });

      - name: Cleanup old images
        if: success()
        uses: ./.github/actions/cleanup-images
        with:
          ssh-user: ${{ vars.SSH_USER }}
          ssh-host: ${{ vars.SSH_HOST }}
          ssh-port: ${{ env.SSH_PORT }}
          image-registry: ${{ env.IMAGE_REGISTRY }}

      - name: Logout from GHCR
        if: always()
        run: |
          ssh -p ${{ env.SSH_PORT }} -i ~/.ssh/id_rsa ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} "docker logout ghcr.io" 2>/dev/null || true

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/id_rsa

  post-deploy:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [validate, deploy-production]
    if: success()
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge to main
        run: |
          BRANCH="${{ github.ref_name }}"
          git fetch origin main
          git checkout main
          git merge origin/$BRANCH --no-ff -m "Merge $BRANCH into main after production deployment"
          git push origin main

      - name: Create and push tag
        run: |
          VERSION="${{ needs.validate.outputs.version }}"
          git tag -a "$VERSION" -m "Release $VERSION - Production deployment"
          git push origin "$VERSION"

  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate, deploy-production, post-deploy]
    if: always()
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Send notifications
        uses: ./.github/actions/notify
        with:
          mode: deploy
          status: ${{ needs.deploy-production.result == 'success' && needs.post-deploy.result == 'success' && 'success' || 'failure' }}
          environment-name: Production
          domain: ${{ env.PROD_DOMAIN }}
          version: ${{ needs.validate.outputs.version }}
          services-deployed: ${{ needs.validate.outputs.services_list || 'all' }}
          service-status: ${{ needs.deploy-production.outputs.service_status }}
          deployed-by: ${{ github.actor }}
          slack-webhook-url: ${{ secrets.SLACK_WEBHOOK_URL }}
          discord-webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          github-ref-name: ${{ github.ref_name }}
          github-sha: ${{ github.sha }}
          github-server-url: ${{ github.server_url }}
          github-repository: ${{ github.repository }}
          github-run-id: ${{ github.run_id }}
